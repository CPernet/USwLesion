function [fn_out,fn_nc] = crc_binarize_segm(fn_in,fn_msk,opt)
%
% Simple routine to binarize the posterior probability images (c_i)
% generated by segmenting structural images and return binarey (b_i)
% images.
%
% The idea is to assign each voxel to one specific tissue class according
% to one and/or more criteria. A voxel is said to be of class i (b_i = 1)
% if the probability of being i is higher than
% - a fixed threshold, i.e. a classic binarization;
% - that of being any other class, i.e. a "most likely" binarization;
% - the sum of probabilities to be from the other classes, i.e. a "more
%   likely than the rest" binarization.
%  An extra image (nc) is generated containing all the voxels that are not
%  assigned to any class (no-class voxels).
%
% FORMAT
%   [fn_out,fn_nc] = crc_binarize_segm(fn_in,fn_msk,opt)
%   [vx_out,vx_nc] = crc_binarize_segm(vx_in,vx_msk,opt)
%
% INPUT:
% - fn_in  : file name of the posterior probabilities (c_i) or a 4D array
%            with the pre-loaded images.
% - fn_msk : binary mask defining which bit of the image is to be
%            considered. By default [], i.e. no masking.
% - opt    : set of options
%   .bin_classic : classic binarization (true by default)
%   .bin_ML      : "most likely" binarization (true by default)
%   .bin_mltr    : "more likely than the rest" binarization, (false by default)
%   .thr         : fixed threshold for classic binarization (.2 by default)
%   .singleImg   : force consider there is only one single image for input 
%                  (false by default).
%
% OUTPUT:
% - fn_out : file name of the binarized tissue classes (b_i) or a 4D array
%            with the voxel values
% - fn_nc  : file name of the no-class voxel image (nc) or 3D array with
%            the voxel values
%
% NOTE:
% - the ML and mltr binarization are mutually exclusive, i.e. only one of
%   these 2 can be applied. ML will have priority if both are selected.
% - wehn classic and ML/mltr binarization are used together, then voxels
%   must meet both criteria (like a 'AND').
% - all input images and mask should have excactly the same number of
%   voxels and orientation!
% - this is only useful when passing multiple images. For a single 3D
%   image, you should set the option 'singleImg' to true. This desables any
%   ML/mltr binarization!
%
%_______________________________________________________________________
% Copyright (C) 2015 Cyclotron Research Centre

% Written by C. Phillips.
% Cyclotron Research Centre, University of Liege, Belgium

%% Deal with options
opt_def = struct(... % Default options
    'bin_classic', true, ...
    'bin_ML', true, ...
    'bin_mltr', false, ...
    'singleImg', false, ...
    'thr', .2);
opt = crc_check_flag(opt_def,opt);

if opt.singleImg
    opt.bin_ML = false;   %\_ No comaprison across multiple maps possible
    opt.bin_mltr = false; %/
end

%% Deal with input files/data
if nargin<2, fn_msk = []; end % if no mask
if nargin<1
    warning('Wrong input format, see help here under.')
    help crc_binarize_segm;
    return
end

% input images
if ischar(fn_in)
    V_in = spm_vol(fn_in);
    spm_check_orientations(V_in);
    vx_in = spm_read_vols(V_in);
    save_img = true;
elseif isnumeric(fn_in)
    vx_in = fn_in;
    save_img = false;
else
    error('Wrong input format!');
end

% get sizes and vectorize images
SZ_in = size(vx_in); % could be a 4D (N 3D images) or 2D (N vectorized images) array
if opt.singleImg
    Nb_in = 1; % case of a single image...
    SZ_in = [SZ_in 1];
    vx_in = vx_in(:);
else
    Nb_in = SZ_in(end); % Last size should be number of images
    vx_in = reshape(vx_in,[prod(SZ_in(1:end-1)) Nb_in]);
end

% mask image
if isempty(fn_msk)
    apply_mask = false; % No masking
else
    apply_mask = true; % use mask but should do further checks!
    if ischar(fn_msk) && ischar(fn_in)
        V_msk = spm_vol(fn_msk);
        spm_check_orientations([V_in(1) ; V_mask])
        vx_msk = spm_read_vols(V_msk);
        vx_msk = vx_msk(:);
    elseif isnumerical(fn_msk) && isnumeric(fn_in)
        vx_msk = fn_msk;
        if any(size(vx_msk~=SZ_in(1:end-1)))
            warning(['Mismatch between mask and input volume.' ...
                'No mask applied!'])
            apply_mask = false;
        else
            vx_msk = vx_msk(:);
        end
    else
        warning(['Wrong mask volume format or incompatibility with ' ...
            'input volumes. No mask applied!'])
        apply_mask = false;
    end
end

%% Apply the binarization
% One at a time and mask at the end.

% initialize vectorized binary volume(s)
bi = zeros(prod(SZ_in(1:end-1)),Nb_in);

if opt.bin_classic
    bi = vx_in>opt.thr;
end

if opt.bin_ML % should have a p higher than all the others individually
    list_c = 1:Nb_in;
    u_vec = zeros(1,Nb_in-1);
    for ii=1:list_c %#ok<*BDSCI>
        list_c_ii = list_c; list_c_ii(ii) = []; % list of others
        bi(:,ii) = sum((vx_in(:,ii)*u_vec)>vx_in(:,list_c_ii),2)==(Nb_in-1);
    end
end

if opt.bin_mltr % should have a p higher than the sum of the others
    list_c = 1:Nb_in;
    u_vec = zeros(1,Nb_in-1);
    for ii=1:list_c %#ok<*BDSCI>
        list_c_ii = list_c; list_c_ii(ii) = []; % list of others
        bi(:,ii) = (vx_in(:,ii)*u_vec)>sum(vx_in(:,list_c_ii),2);
    end
end

% left out voxels, i.e. not-classified (nc)
nc = ~sum(bi,2);

% apply mask, if requested
if apply_mask
    for ii=1:Nb_in
        bi(:,ii) = bi(:,ii) .* vx_msk;
    end
    nc = nc .* vx_msk;
end

% reshape into original shape

%% write down images or pass values
if save_img
    % create images from bi and nc
    fn_out = spm_file(fn_in, 'prefix', 'b');
    V_out = V_in;
    for ii=1:Nb_in
        V_out(ii).fname = deblank(fn_out(ii,:));
        V_out(ii) = spm_write_vol(V_out(ii),reshape(bi(:,ii),SZ_in(1:end-1)));
    end
    fn_nc = spm_file(fn_in(1,:), 'prefix', 'nc');
    V_nc = V_in(1);
    V_nc.fname = deblank(fn_nc);
    V_nc = spm_write_vol(V_nc,reshape(nc,SZ_in(1:end-1))); %#ok<*NASGU>
else
    % just change the name
    fn_out = reshape(bi,SZ_in);
    fn_nc = reshape(nc,SZ_in(1:end-1));
end

end


